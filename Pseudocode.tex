\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{cases}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{algorithm}
\usepackage{algpseudocode}
\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\INPUT{\item[\algorithmicinput]}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\OUTPUT{\item[\algorithmicoutput]}


\usepackage{geometry}
 \geometry{
 a4paper,
 total={210mm,297mm},
 left=20mm,
 right=20mm,
 top=20mm,
 bottom=20mm,
 }

\begin{document}
\begin{enumerate}

\item Machine Learning Algorithms Pseudocode
  \begin{algorithm}
   \caption{k-Nearest Neighbor}
    \begin{algorithmic}[1]
    \INPUT{X: training data, Y:Class labels of X, $x$: unknown sample}
     \OUTPUT{Class with the highest number of occurrence}
      \Function{Classify}{$X,Y,x$}\
       \For{$i = 1$ to ${m}$}
            \State Compute distance $d{(X_i,x)}$
        \EndFor
        
         \State Compute set $I$ containing indices for the $k$ smallest distances $d{(X_i,x)}$
     
       \State Return majority label $\{Y_i \ \text{where}\ i \in I \}$



 \EndFunction

\end{algorithmic}
\end{algorithm}
\end{enumerate}

\begin{enumerate}

\item Ensemble Algorithm
  \begin{algorithm}
   \caption{Adaboost}
    \begin{algorithmic}[1]
    \INPUT 
    \Statex Training data $\{(x_i,y_i)_{i=1}^N \ \text{where}\ x_i \in  \mathbb{R}^k \ \text{and} \  y_i \in \{-1,1\} \}$
    \Statex Large number of classifiers denoted by $f_m(x) \in \{-1,1\} $
    \Statex 0-1 loss function $I$ defined as 
 \begin{numcases}{ I(f_m(x,y))=}
  0, & if $ f_m(x_i) = y_i $\\
  1, &  if $ f_m(x_i) \neq y_i $
\end{numcases}
     \OUTPUT{The final classifier}
     
       \For{$i = 1$ to ${N}$}
       \For{$i = 1$ to ${M}$}
            \State Fit weak classifier m to minimize the objective function:
            \State $\epsilon_m =  \frac{\sum_{i=1}^N w_{i}^m I(f_m(x_i)) \neq y_i}{x^2+2x+1} $
            \State where  $I(f_m(x_i) \neq y_i) =1 \  \text{if} \ f_m(x_i) \neq y_i  $ and 0 otherwise
            \State $\alpha_m = \ln \frac{1- \epsilon_m}{\epsilon_m}$
            
        \EndFor
         \For{ all $i$ }
              \State $w_{i}^ {m+1} = w_{i} ^{(m)} e^{\alpha_{mI(f_m(x_i) \neq y_i)}} $ 
         \EndFor 
         
        
        \EndFor
        
        


\end{algorithmic}
\end{algorithm}
\end{enumerate}


\begin{enumerate}

\item Another Pseudocode for Adaboost
  \begin{algorithm}
   \caption{Adaboost}
    \begin{algorithmic}[1]
    \INPUT 
    \Statex Training data $\{(x_i,y_i)_{i=1}^N \ \text{where}\ x_i \in  \mathbb{R}^k \ \text{and} \  y_i \in \{-1,1\} \}$
   
     \OUTPUT{The final classifier}
    \State Given Training data $\{(x_i,y_i) \ \text{where}\  \  y_i \in \{-1,1\} \}$
    \State initialize $D_1$ = uniform distribution on training examples
       \For{$t = 1$ to ${T}$}
   
            \State Train weak classifier $h_t \  \text{on}\   \   D_t $
            \State choose $\alpha_t > 0 $
            \State compute new distribution $D_{t+1}$:
             \For{ all $i$ }
              \State multiply $D_t(x)$ by \begin{numcases}{}
  e^{-\alpha_t}, &  ($<1$) $ \text{if}\  \  y_i = h_t(x_i) $\\
   e^{\alpha_t}, & ($>1$) $ \text{if}\  \  y_i \neq h_t(x_i) $
\end{numcases}
\State renormalize
         \EndFor 
         
  \State output final classifier $H_final(x) = sign (\sum\alpha_t h_t(x))$
            
        
        
         
        
        \EndFor
        
        


\end{algorithmic}
\end{algorithm}
\end{enumerate}

\begin{enumerate}

\item Machine Learning Algorithms Pseudocode
  \begin{algorithm}
   \caption{Random forest}
    \begin{algorithmic}[1]
    \INPUT{S: training set, F:Features and number of trees in forest $B$}
     \OUTPUT{Constructed tree}
      \Function{RANDOMFOREST}{$S,F$}\
      \State $H \leftarrow  \emptyset $
       \For{$i \in 1,....B$ }
            \State $S^{(i)}\leftarrow \text{A bootstrap sample from} \  S $
            \State $h_i \leftarrow RANDOMIZEDTREELEARN(S^{i},F)$
            \State $H \leftarrow H \bigcup \{h_i\}$
        \EndFor
        \State return $H$
         



 \EndFunction

  \Function{RANDOMIZEDTREELEARN}{$S,F$}\ 
  \State At each node:
  \State $f \leftarrow \text{a very small subset of} \ F $
  \State Split on best feature in $f$
  \State return The learned tree
   \EndFunction

\end{algorithmic}
\end{algorithm}
\end{enumerate}

\begin{enumerate}

\item Machine Learning Algorithms Pseudocode
  \begin{algorithm}
   \caption{Iterative Dichotomiser 3}
    \begin{algorithmic}[1]
    \INPUT{$D:\text{Training Data}, \ X: \text{Set of Input  Attributes} $}
     \OUTPUT{A decision tree}
      \Function{ID3}{$D,X$}\
      \State Let $T$ be a new tree 
     \If {all instances in $D$ have the same class $c$}
      \State Label ($T$) = $c$; Return $T$
      \EndIf
      \If {$X= \emptyset\ \text{or no attribute has positive information gain} $}
      \State Label ($T$) = most common class in $D$; Return $T$
      \EndIf
      \State $X \leftarrow \ \text{attribute with highest information gain} $
      \State Label($T$) = $X$
       \For{$\text{each value} \ x \  \text{of} \ X$ }
            \State $D_x \leftarrow \ \text{instances in} \ D \ \text{with} \ X = x $
           \If {$D_x \ \text{is empty}$}
           \State Let $T_x \ \text{be a new tree}$
           \State Label($T_x$) = most common class in $D$
           \Else {\State $T_x$ = ID3($D_x,X-\{x\}$)}
           \EndIf
            \State Add a branch from $T$ to $T_x$ labeled by $x$
        \EndFor
        \State return $T$
         



 \EndFunction

 
\end{algorithmic}
\end{algorithm}
\end{enumerate}

\begin{enumerate}

\item Machine Learning Algorithms Pseudocode
  \begin{algorithm}
   \caption{Perceptron}
    \begin{algorithmic}[1]
    \INPUT{$ProblemSize,InputPatterns,iterations_max,learn_rate$}
     \OUTPUT{$Weights$}
    
       \For{$i = 1$ to ${iterations_{max}}$}
            \State $Pattern_i \leftarrow SelectInputPattern(InputPatterns)$
            \State $Activation_i \leftarrow ActivateNetwork(Pattern_i,Weights)$
            \State $Output_i \leftarrow TransferActivation(Activation_i)$
            \State $UpdateWeights(Pattern_i,Output_i,learn_{rate})$
        \EndFor
        
       
       \State Return $Weights$



 

\end{algorithmic}
\end{algorithm}
\end{enumerate}


\end{document}



